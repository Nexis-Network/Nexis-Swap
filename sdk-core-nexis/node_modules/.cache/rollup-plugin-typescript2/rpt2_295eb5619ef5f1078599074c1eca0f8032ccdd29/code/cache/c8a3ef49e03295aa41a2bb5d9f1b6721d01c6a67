{"code":"import { getAddress } from '@ethersproject/address';\r\n/**\r\n * Validates an address and returns the parsed (checksummed) version of that address\r\n * @param address the unchecksummed hex address\r\n */\r\nexport function validateAndParseAddress(address) {\r\n    try {\r\n        return getAddress(address);\r\n    }\r\n    catch (error) {\r\n        throw new Error(`${address} is not a valid address.`);\r\n    }\r\n}\r\n// Checks a string starts with 0x, is 42 characters long and contains only hex characters after 0x\r\nconst startsWith0xLen42HexRegex = /^0x[0-9a-fA-F]{40}$/;\r\n/**\r\n * Checks if an address is valid by checking 0x prefix, length === 42 and hex encoding.\r\n * @param address the unchecksummed hex address\r\n */\r\nexport function checkValidAddress(address) {\r\n    if (startsWith0xLen42HexRegex.test(address)) {\r\n        return address;\r\n    }\r\n    throw new Error(`${address} is not a valid address.`);\r\n}\r\n//# sourceMappingURL=validateAndParseAddress.js.map","references":["/Users/anukul/Desktop/Nexis-Swap/sdk-core-nexis/node_modules/@ethersproject/address/lib/index.d.ts"],"map":"{\"version\":3,\"file\":\"validateAndParseAddress.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/utils/validateAndParseAddress.ts\"],\"names\":[],\"mappings\":\"AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,wBAAwB,CAAA;AAEnD;;;GAGG;AACH,MAAM,UAAU,uBAAuB,CAAC,OAAe;IACrD,IAAI;QACF,OAAO,UAAU,CAAC,OAAO,CAAC,CAAA;KAC3B;IAAC,OAAO,KAAK,EAAE;QACd,MAAM,IAAI,KAAK,CAAC,GAAG,OAAO,0BAA0B,CAAC,CAAA;KACtD;AACH,CAAC;AAED,kGAAkG;AAClG,MAAM,yBAAyB,GAAG,qBAAqB,CAAA;AAEvD;;;GAGG;AACH,MAAM,UAAU,iBAAiB,CAAC,OAAe;IAC/C,IAAI,yBAAyB,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;QAC3C,OAAO,OAAO,CAAA;KACf;IAED,MAAM,IAAI,KAAK,CAAC,GAAG,OAAO,0BAA0B,CAAC,CAAA;AACvD,CAAC\"}","dts":{"name":"/Users/anukul/Desktop/Nexis-Swap/sdk-core-nexis/utils/validateAndParseAddress.d.ts","writeByteOrderMark":false,"text":"/**\r\n * Validates an address and returns the parsed (checksummed) version of that address\r\n * @param address the unchecksummed hex address\r\n */\r\nexport declare function validateAndParseAddress(address: string): string;\r\n/**\r\n * Checks if an address is valid by checking 0x prefix, length === 42 and hex encoding.\r\n * @param address the unchecksummed hex address\r\n */\r\nexport declare function checkValidAddress(address: string): string;\r\n"}}
